use regex::Regex;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // First, compile the proto files as usual
    let mut config = prost_build::Config::new();
    config.type_attribute(".", "#[allow(dead_code)]");

    // Include the shared proto path
    config.compile_protos(
        &[
            "proto/product.proto",
            "proto/category.proto",
            "proto/events.proto",
        ],
        &["proto/", "../shared-proto/proto/"],
    )?;

    // Now extract NATS configuration from proto files
    generate_nats_config()?;

    Ok(())
}

#[derive(Debug, Clone)]
struct ServiceConfig {
    name: String,
    queue: String,
    subject_prefix: String,
    methods: Vec<MethodConfig>,
}

#[derive(Debug, Clone)]
struct MethodConfig {
    name: String,
    subject: String,
    #[allow(dead_code)]
    timeout_ms: Option<u32>,
}

#[derive(Debug, Clone)]
struct EventConfig {
    name: String,
    subject: String,
    is_publisher: bool,
}

fn generate_nats_config() -> Result<(), Box<dyn std::error::Error>> {
    let mut services = Vec::new();
    let mut events = Vec::new();

    // Parse product.proto
    if let Ok(content) = fs::read_to_string("proto/product.proto") {
        if let Some(service) = parse_service(&content, "ProductService") {
            services.push(service);
        }
        events.extend(parse_events(&content));
    }

    // Parse category.proto
    if let Ok(content) = fs::read_to_string("proto/category.proto") {
        if let Some(service) = parse_service(&content, "CategoryService") {
            services.push(service);
        }
        events.extend(parse_events(&content));
    }

    // Parse events.proto
    if let Ok(content) = fs::read_to_string("proto/events.proto") {
        events.extend(parse_events(&content));
    }

    // Generate the Rust code
    let out_dir = std::env::var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("nats_config.rs");
    let mut file = fs::File::create(&dest_path)?;

    writeln!(file, "// This file is automatically generated by build.rs")?;
    writeln!(
        file,
        "// Do not edit manually - changes will be overwritten"
    )?;
    writeln!(file)?;
    writeln!(file, "pub mod nats_config {{")?;

    // Generate service configurations
    for service in &services {
        let module_name = to_snake_case(&service.name.replace("Service", ""));
        writeln!(file, "    pub mod {module_name} {{")?;
        writeln!(
            file,
            "        pub const QUEUE: &str = \"{}\";",
            service.queue
        )?;
        writeln!(
            file,
            "        pub const SUBJECT_PREFIX: &str = \"{}\";",
            service.subject_prefix
        )?;
        writeln!(file)?;
        writeln!(file, "        pub mod subjects {{")?;

        for method in &service.methods {
            let const_name = to_screaming_snake_case(&method.name);
            writeln!(
                file,
                "            pub const {}: &str = \"{}.{}\";",
                const_name, service.subject_prefix, method.subject
            )?;
        }

        writeln!(file, "        }}")?;
        writeln!(file)?;

        // Generate a helper function to get all routes
        writeln!(
            file,
            "        pub fn routes() -> Vec<(&'static str, &'static str)> {{"
        )?;
        writeln!(file, "            vec![")?;
        for method in &service.methods {
            writeln!(
                file,
                "                (\"{}\", subjects::{}),",
                method.subject,
                to_screaming_snake_case(&method.name)
            )?;
        }
        writeln!(file, "            ]")?;
        writeln!(file, "        }}")?;

        writeln!(file, "    }}")?;
        writeln!(file)?;
    }

    // Generate event configurations
    writeln!(file, "    pub mod events {{")?;

    // Published events
    writeln!(file, "        pub mod published {{")?;
    for event in events.iter().filter(|e| e.is_publisher) {
        let const_name = to_screaming_snake_case(&event.name);
        writeln!(
            file,
            "            pub const {}: &str = \"{}\";",
            const_name, event.subject
        )?;
    }
    writeln!(file, "        }}")?;
    writeln!(file)?;

    // Consumed events
    writeln!(file, "        pub mod consumed {{")?;
    for event in events.iter().filter(|e| !e.is_publisher) {
        let const_name = to_screaming_snake_case(&event.name);
        writeln!(
            file,
            "            pub const {}: &str = \"{}\";",
            const_name, event.subject
        )?;
    }
    writeln!(file, "        }}")?;

    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;

    println!("cargo:rerun-if-changed=proto/product.proto");
    println!("cargo:rerun-if-changed=proto/category.proto");
    println!("cargo:rerun-if-changed=proto/events.proto");

    Ok(())
}

fn parse_service(content: &str, service_name: &str) -> Option<ServiceConfig> {
    // Find the service definition
    let service_regex = Regex::new(&format!(r"service\s+{service_name}\s*\{{")).ok()?;
    let service_start = service_regex.find(content)?;

    // Extract service options
    let queue = extract_option(content, service_start.start(), "queue")?;
    let subject_prefix = extract_option(content, service_start.start(), "subject_prefix")?;

    // Find all RPC methods
    let mut methods = Vec::new();
    let rpc_regex =
        Regex::new(r"rpc\s+(\w+)\s*\([^)]+\)\s*returns\s*\([^)]+\)\s*\{([^}]*)\}").ok()?;

    // Find the end of the service block
    let service_end = find_matching_brace(content, service_start.end())?;
    let service_content = &content[service_start.start()..service_end];

    for cap in rpc_regex.captures_iter(service_content) {
        let method_name = cap.get(1)?.as_str().to_string();
        let options_block = cap.get(2)?.as_str();

        // Extract subject from options
        let subject = extract_option_from_block(options_block, "subject")
            .unwrap_or_else(|| to_snake_case(&method_name));

        let timeout_ms = extract_option_from_block(options_block, "timeout_ms")
            .and_then(|s| s.parse::<u32>().ok());

        methods.push(MethodConfig {
            name: method_name,
            subject,
            timeout_ms,
        });
    }

    Some(ServiceConfig {
        name: service_name.to_string(),
        queue,
        subject_prefix,
        methods,
    })
}

fn parse_events(content: &str) -> Vec<EventConfig> {
    let mut events = Vec::new();

    // Parse event options
    let event_regex =
        Regex::new(r#"option\s+\(nats\.options\.events\)\s*=\s*\{([^}]*)\}"#).unwrap();

    for cap in event_regex.captures_iter(content) {
        let options_block = cap.get(1).unwrap().as_str();

        if let (Some(name), Some(subject)) = (
            extract_quoted_value(options_block, "name"),
            extract_quoted_value(options_block, "subject"),
        ) {
            let is_publisher = options_block.contains("is_publisher: true")
                || options_block.contains("is_publisher:true");

            events.push(EventConfig {
                name,
                subject,
                is_publisher,
            });
        }
    }

    events
}

fn extract_option(content: &str, start_pos: usize, option_name: &str) -> Option<String> {
    let search_area = &content[start_pos..];
    let option_regex = Regex::new(&format!(
        r#"option\s+\(nats\.options\.{option_name}\)\s*=\s*"([^"]*)""#
    ))
    .ok()?;

    option_regex
        .captures(search_area)?
        .get(1)
        .map(|m| m.as_str().to_string())
}

fn extract_option_from_block(block: &str, option_name: &str) -> Option<String> {
    let option_regex = Regex::new(&format!(
        r#"\(nats\.options\.{option_name}\)\s*=\s*"([^"]*)""#
    ))
    .ok()?;

    option_regex
        .captures(block)?
        .get(1)
        .map(|m| m.as_str().to_string())
}

fn extract_quoted_value(block: &str, field_name: &str) -> Option<String> {
    let regex = Regex::new(&format!(r#"{field_name}:\s*"([^"]*)""#)).ok()?;
    regex
        .captures(block)?
        .get(1)
        .map(|m| m.as_str().to_string())
}

fn find_matching_brace(content: &str, start: usize) -> Option<usize> {
    let mut depth = 1;
    let mut pos = start;
    let chars: Vec<char> = content.chars().collect();

    while pos < chars.len() && depth > 0 {
        match chars[pos] {
            '{' => depth += 1,
            '}' => depth -= 1,
            _ => {}
        }
        pos += 1;
    }

    if depth == 0 {
        Some(pos)
    } else {
        None
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(ch.to_lowercase().next().unwrap());
    }
    result
}

fn to_screaming_snake_case(s: &str) -> String {
    to_snake_case(s).to_uppercase()
}
