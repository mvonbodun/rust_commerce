#!/usr/bin/env tsx

import * as fs from 'fs';
import * as path from 'path';

interface ServiceConfig {
  name: string;
  queue: string;
  subjectPrefix: string;
  methods: MethodConfig[];
}

interface MethodConfig {
  name: string;
  subject: string;
  timeoutMs?: number;
}

interface EventConfig {
  name: string;
  subject: string;
  isPublisher: boolean;
}

function parseProtoFile(filePath: string): { services: ServiceConfig[], events: EventConfig[] } {
  const content = fs.readFileSync(filePath, 'utf-8');
  const services: ServiceConfig[] = [];
  const events: EventConfig[] = [];

  // Parse service definitions
  const serviceRegex = /service\s+(\w+)\s*\{/g;
  let serviceMatch;
  
  while ((serviceMatch = serviceRegex.exec(content)) !== null) {
    const serviceName = serviceMatch[1];
    const serviceStart = serviceMatch.index + serviceMatch[0].length;
    
    // Find the end of the service block
    let braceCount = 1;
    let serviceEnd = serviceStart;
    while (braceCount > 0 && serviceEnd < content.length) {
      if (content[serviceEnd] === '{') braceCount++;
      if (content[serviceEnd] === '}') braceCount--;
      serviceEnd++;
    }
    
    const serviceContent = content.substring(serviceStart, serviceEnd - 1);
    
    // Extract service options from before the service block
    const beforeService = content.substring(0, serviceMatch.index);
    const lastBraceIndex = beforeService.lastIndexOf('}');
    const searchArea = content.substring(lastBraceIndex > 0 ? lastBraceIndex : 0, serviceEnd);
    
    const queueMatch = /option\s+\(nats\.options\.queue\)\s*=\s*"([^"]+)"/.exec(searchArea);
    const prefixMatch = /option\s+\(nats\.options\.subject_prefix\)\s*=\s*"([^"]+)"/.exec(searchArea);
    
    if (queueMatch && prefixMatch) {
      const methods: MethodConfig[] = [];
      
      // Parse RPC methods - they can span multiple lines
      const rpcRegex = /rpc\s+(\w+)\s*\([^)]+\)\s*returns\s*\([^)]+\)\s*\{/g;
      let rpcMatch;
      
      while ((rpcMatch = rpcRegex.exec(serviceContent)) !== null) {
        const methodName = rpcMatch[1];
        const methodStart = rpcMatch.index + rpcMatch[0].length;
        
        // Find the end of the method block
        let methodBraceCount = 1;
        let methodEnd = methodStart;
        while (methodBraceCount > 0 && methodEnd < serviceContent.length) {
          if (serviceContent[methodEnd] === '{') methodBraceCount++;
          if (serviceContent[methodEnd] === '}') methodBraceCount--;
          methodEnd++;
        }
        
        const methodOptions = serviceContent.substring(methodStart, methodEnd - 1);
        
        const subjectMatch = /\(nats\.options\.subject\)\s*=\s*"([^"]+)"/.exec(methodOptions);
        const timeoutMatch = /\(nats\.options\.timeout_ms\)\s*=\s*(\d+)/.exec(methodOptions);
        
        methods.push({
          name: methodName,
          subject: subjectMatch ? subjectMatch[1] : toSnakeCase(methodName),
          timeoutMs: timeoutMatch ? parseInt(timeoutMatch[1]) : undefined
        });
      }
      
      services.push({
        name: serviceName,
        queue: queueMatch[1],
        subjectPrefix: prefixMatch[1],
        methods
      });
    }
  }

  // Parse event definitions
  const eventRegex = /option\s+\(nats\.options\.events\)\s*=\s*\{([^}]*)\}/g;
  let eventMatch;
  
  while ((eventMatch = eventRegex.exec(content)) !== null) {
    const eventBlock = eventMatch[1];
    
    const nameMatch = /name:\s*"([^"]+)"/.exec(eventBlock);
    const subjectMatch = /subject:\s*"([^"]+)"/.exec(eventBlock);
    const isPublisher = /is_publisher:\s*true/.test(eventBlock);
    
    if (nameMatch && subjectMatch) {
      events.push({
        name: nameMatch[1],
        subject: subjectMatch[1],
        isPublisher
      });
    }
  }

  return { services, events };
}

function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, (_match, p1, offset) => {
    return offset > 0 ? '_' + p1.toLowerCase() : p1.toLowerCase();
  });
}

function toCamelCase(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

function generateTypeScriptConfig(services: ServiceConfig[], events: EventConfig[]): string {
  let output = `// This file is automatically generated by generate-nats-config.ts
// Do not edit manually - changes will be overwritten

export const NatsConfig = {
`;

  // Generate service configurations
  for (const service of services) {
    const moduleName = toCamelCase(service.name.replace('Service', ''));
    output += `  ${moduleName}: {\n`;
    output += `    queue: '${service.queue}',\n`;
    output += `    subjectPrefix: '${service.subjectPrefix}',\n`;
    output += `    subjects: {\n`;
    
    for (const method of service.methods) {
      const methodKey = toCamelCase(method.subject);
      output += `      ${methodKey}: '${service.subjectPrefix}.${method.subject}',\n`;
    }
    
    output += `    },\n`;
    output += `    methods: {\n`;
    
    for (const method of service.methods) {
      output += `      ${toCamelCase(method.name)}: {\n`;
      output += `        subject: '${service.subjectPrefix}.${method.subject}',\n`;
      if (method.timeoutMs) {
        output += `        timeoutMs: ${method.timeoutMs},\n`;
      }
      output += `      },\n`;
    }
    
    output += `    },\n`;
    output += `  },\n`;
  }

  // Generate event configurations
  if (events.length > 0) {
    output += `  events: {\n`;
    output += `    published: {\n`;
    
    for (const event of events.filter(e => e.isPublisher)) {
      output += `      ${toCamelCase(event.name)}: '${event.subject}',\n`;
    }
    
    output += `    },\n`;
    output += `    consumed: {\n`;
    
    for (const event of events.filter(e => !e.isPublisher)) {
      output += `      ${toCamelCase(event.name)}: '${event.subject}',\n`;
    }
    
    output += `    },\n`;
    output += `  },\n`;
  }

  output += `} as const;\n\n`;
  output += `export type NatsConfigType = typeof NatsConfig;\n`;

  return output;
}

async function main() {
  console.log('ðŸ”§ Generating NATS configuration from proto files...');
  
  const services: ServiceConfig[] = [];
  const events: EventConfig[] = [];
  
  // Parse catalog proto files
  const catalogProtoDir = path.join(__dirname, '../../catalog/proto');
  const protoFiles = fs.readdirSync(catalogProtoDir).filter(f => f.endsWith('.proto'));
  
  for (const file of protoFiles) {
    const filePath = path.join(catalogProtoDir, file);
    console.log(`  ðŸ“„ Parsing ${file}...`);
    const { services: fileServices, events: fileEvents } = parseProtoFile(filePath);
    services.push(...fileServices);
    events.push(...fileEvents);
  }
  
  // Generate TypeScript configuration
  const tsConfig = generateTypeScriptConfig(services, events);
  
  // Write to file
  const outputPath = path.join(__dirname, '../generated/nats-config.ts');
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, tsConfig);
  
  console.log(`âœ… Generated NATS configuration with ${services.length} services and ${events.length} events`);
  console.log(`   Output: ${outputPath}`);
}

main().catch(console.error);